---
- set_fact:
    le_backup_certbot_files:
      - cert.pem
      - chain.pem
      - combined.pem
      - fullchain.pem
      - privkey.pem
    le_source_path: /etc/letsencrypt/live
    le_backup_path: /root/letsencrypt-cert-backup
  tags:
    - certbot

- name: install certbot package
  package: name=certbot state=present
  tags:
    - certbot

- name: install certbot config
  template: src=certbot.j2 dest=/etc/sysconfig/certbot
            mode=0644
  tags:
    - certbot

- name: install certbot deploy script
  template: src={{ letsencrypt.predefined_deploy_script }}
            dest=/usr/libexec/auto-certbot-deploy
            mode=0755
  when: letsencrypt.predefined_deploy_script is defined
  tags:
    - certbot

- name: check whether we need to initialize letsencrypt first
  stat: path="/etc/letsencrypt/live/{{ item.key }}"
  register: le_stat_checks
  with_dict: "{{ letsencrypt.certificates }}"
  tags:
    - certbot

- name: load the backed up certificates
  delegate_to: "{{ letsencrypt.backup_to }}"
  slurp:
    src: "{{ le_backup_path }}/{{ item.0.item.key }}/{{ item.1 }}"
  register: backed_up_certificates
  loop: "{{ le_stat_checks.results|product(le_backup_certbot_files)|list }}"
  ignore_errors: true
  tags:
    - certbot
  when:
    - letsencrypt.backup_to is defined
    - not item.0.stat.exists

- name: create the host directory
  file:
    state: directory
    path: "{{ le_source_path }}/{{ item.item.0.item.key }}"
    owner: root
    group: root
    # this is readable by anyone, per certbot defaults
    mode: 0755
  loop: "{{ backed_up_certificates.results }}"
  tags:
    - certbot
  when:
    - letsencrypt.backup_to is defined
    - item.content is defined

- name: create the archive directory
  file:
    state: directory
    path: "{{ le_source_path }}/../archive"
    owner: root
    group: root
    # this is readable by anyone, per certbot defaults
    mode: 0755
  loop: "{{ backed_up_certificates.results }}"
  tags:
    - certbot
  when:
    - letsencrypt.backup_to is defined
    - item.content is defined

- name: create the archive host directorY
  file:
    state: directory
    path: "{{ le_source_path }}/../archive/{{ item.item.0.item.key }}"
    owner: root
    group: root
    # this is readable by anyone, per certbot defaults
    mode: 0755
  loop: "{{ backed_up_certificates.results }}"
  tags:
    - certbot
  when:
    - letsencrypt.backup_to is defined
    - item.content is defined

- name: restore the backed up certificates
  copy:
    content: "{{ item.content | b64decode }}"
    dest: "{{ le_source_path }}/../archive/{{ item.item.0.item.key }}/restored{{ item.item.1 }}"
    owner: root
    group: root
    mode: 0644
  loop: "{{ backed_up_certificates.results }}"
  tags:
    - certbot
  when:
    - letsencrypt.backup_to is defined
    - item.content is defined
  register: some_cert_restored

- name: restore the cert symlinks
  file:
    state: link
    src: "../../archive/{{ item.item.0.item.key }}/restored{{ item.item.1 }}"
    dest: "{{ le_source_path }}/{{ item.item.0.item.key }}/{{ item.item.1 }}"
    owner: root
    group: root
  loop: "{{ backed_up_certificates.results }}"
  tags:
    - certbot
  when:
    - letsencrypt.backup_to is defined
    - item.content is defined
  register: some_cert_restored

- name: initialize certbot configuration
  shell: |
      certbot certonly --standalone \
            -w {{ item.item.value.challenge_dir }} \
            -d {{ item.item.value.domains | join(' -d ') }} \
            --cert-name {{ item.item.key }} \
            -m {{ item.item.value.mail }} \
            --agree-tos \
            -n >> /tmp/call
  when:
    - not item.stat.exists
    - not some_cert_restored.changed
  with_items: "{{ le_stat_checks.results }}"
  tags:
    - certbot

- name: configure certbot to use webroot next time
  ini_file: dest="/etc/letsencrypt/renewal/{{ item.item.key }}.conf"
            section=renewalparams
            option=authenticator
            value=webroot
  with_items: "{{ le_stat_checks.results }}"
  tags:
    - certbot

- name: configure certbot to use webroot next time
  ini_file: dest="/etc/letsencrypt/renewal/{{ item.item.key }}.conf"
            section=renewalparams
            option=webroot_path
            value="{{ item.item.value.challenge_dir }}"
  with_items: "{{ le_stat_checks.results }}"
  tags:
    - certbot

- name: post init script
  shell: |
      /usr/libexec/auto-certbot-deploy \
            --init {{ item.item.key }}
  when:
    - letsencrypt.predefined_deploy_script is defined
    - not item.stat.exists
    - not some_cert_restored.changed
  with_items: "{{ le_stat_checks.results }}"
  with_items: "{{ le_stat_checks.results }}"
  tags:
    - certbot

- name: Automatize cert renewal
  service:
    name: certbot-renew.timer
    state: started
    enabled: yes
  tags:
    - certbot

# When we do 'systemctl restart', lighttpd is initially started as "root"
# process (when the config is loaded) and later it does setuid(lighttpd).
# So "restart" is just fine.   Though we also do 'killall -HUP lighttpd' in
# several occasions and then 'lighttpd' user needs to have the access.  See the
# following issues:
#   https://pagure.io/copr/copr/issue/2001 Resolves:
#   https://pagure.io/fedora-infrastructure/issue/10391
- name: allow lighttpd to step into certbots directories
  acl:
    path: "{{ item }}"
    entity: lighttpd
    etype: user
    permissions: --x
    state: present
  with_items:
    - /etc/letsencrypt/archive
    - /etc/letsencrypt/live
  when:
    - letsencrypt.predefined_deploy_script is defined
    - letsencrypt.predefined_deploy_script == 'lighttpd'
  tags:
    - certbot

- name: load certificate files into variables
  slurp:
    src: "{{ le_source_path }}/{{ item.0.0 }}/{{ item.1 }}"
  register: certbot_backup_files
  ignore_errors: true
  loop: "{{letsencrypt.certificates|dictsort|product(le_backup_certbot_files)|list}}"
  when:
    - letsencrypt.backup_to is defined
  tags:
    - certbot

- name: create the restore directory
  delegate_to: "{{ letsencrypt.backup_to }}"
  file:
    path: "{{ le_backup_path }}"
    owner: root
    group: root
    mode: 0700
    state: directory
  when:
    - letsencrypt.backup_to is defined
  tags:
    - certbot

- name: create the host restore directories
  delegate_to: "{{ letsencrypt.backup_to }}"
  file:
    owner: root
    group: root
    mode: 0700
    path: "{{ le_backup_path }}/{{ item.0 }}"
    state: directory
  loop: "{{ letsencrypt.certificates|dictsort }}"
  when:
    - letsencrypt.backup_to is defined
  tags:
    - certbot

- name: store files
  delegate_to: "{{ letsencrypt.backup_to }}"
  copy:
    dest: "{{ le_backup_path }}/{{ item.item.0.0 }}/{{ item.item.1 }}"
    owner: root
    group: root
    mode: 0600
    content: "{{ item.content | b64decode }}"
  when:
    - item.content is defined
  loop: "{{ certbot_backup_files.results }}"
  no_log: true
  tags:
    - certbot
